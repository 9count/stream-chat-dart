import 'dart:convert';

import 'package:logging/logging.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:stream_chat/src/db/offline_storage.dart';
import 'package:stream_chat/src/models/channel_model.dart';
import 'package:stream_chat/src/models/channel_state.dart';
import 'package:stream_chat/src/models/message.dart';

import 'client.dart';
import 'models/own_user.dart';

class _NotificationData {
  final Message message;
  final ChannelModel channel;

  _NotificationData(
    this.message,
    this.channel,
  );
}

/// Utility class to handle and show notifications
class NotificationService {
  static Future<void> _handleNotification(
    Message message,
    ChannelModel channelModel,
    Client client,
  ) async {
    if (message != null && client.persistenceEnabled) {
      if (client?.state?.channels == null) {
        final sharedPreferences = await SharedPreferences.getInstance();
        final userId = sharedPreferences.getString(KEY_USER_ID);

        final offlineStorage = OfflineStorage(userId, Logger('ðŸ’½'));
        await offlineStorage.updateChannelState(
          ChannelState(
            channel: channelModel,
            messages: [message],
          ),
        );
        await offlineStorage.disconnect();
      } else {
        final channel = client.state.channels[channelModel.cid];
        channel.state.updateChannelState(
          ChannelState(
            channel: channelModel,
            messages: [message],
          ),
        );
      }
    }
  }

  /// Gets the message using the client without storing it in the offline storage
  /// It returns an object containing the information about the message and the channel
  static Future<_NotificationData> getMessage(String messageId) async {
    final sharedPreferences = await SharedPreferences.getInstance();
    final apiKey = sharedPreferences.getString(KEY_API_KEY);

    final client = Client(
      apiKey,
      persistenceEnabled: false,
    );
    final userId = sharedPreferences.getString(KEY_USER_ID);
    final token = sharedPreferences.getString(KEY_TOKEN);

    client.state.user = OwnUser(id: userId);
    client.token = token;

    final res = await client.getMessage(messageId);
    final message = res.message;
    final channel = ChannelModel.fromJson(message.extraData['channel']);
    final messageChannel = _NotificationData(message, channel);

    return messageChannel;
  }

  /// Gets the message using the client and stores it in the offline storage
  /// It returns an object containing the information about the message and the channel
  static Future<_NotificationData> getAndStoreMessage(
    String messageId,
  ) async {
    final sharedPreferences = await SharedPreferences.getInstance();
    final userId = sharedPreferences.getString(KEY_USER_ID);

    final notificationData = await getMessage(messageId);

    final offlineStorage = OfflineStorage(
      userId,
      Logger('ðŸ’½'),
    );

    await offlineStorage.updateChannelState(ChannelState(
      messages: [notificationData.message],
      channel: notificationData.channel,
    ));

    await offlineStorage.disconnect();

    return notificationData;
  }

  /// Handles the ios message queue generated by the Notification Service Extension
  static Future<void> handleIosMessageQueue(Client client) async {
    final sharedPreferences = await SharedPreferences.getInstance();
    await sharedPreferences.reload();
    final messageQueue = sharedPreferences.getStringList('messageQueue');
    if (messageQueue != null) {
      messageQueue.forEach((m) {
        final jsonMessage = jsonDecode(m);

        final message = Message.fromJson(jsonMessage);
        final channelModel = ChannelModel.fromJson(jsonMessage['channel']);

        _handleNotification(
          message,
          channelModel,
          client,
        );
      });
      await sharedPreferences.remove('messageQueue');
    }
  }
}
